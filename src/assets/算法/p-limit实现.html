<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025-03 p-limit 使用+源码 、100个请求并发请求、分时操作</title>
</head>

<body>
    <script type="module">
        import pLimit, { limitFunction } from 'p-limit';
        const promiseArr = Array.from({ length: 30 }, (it, index) => new Promise(resolve => setTimeout(resolve, index * 99, index)))
        // 方法1
        const limit = pLimit(6);
        const limitedArr = promiseArr.map(it => limit(() => it));
        Promise.all(limitedArr).then(res => console.log(res))
        // 方法2
        // ❌ 1、const limitedArr2 = promiseArr.map(it => limitFunction(() => it)) - limitFunction 缺少函数传入 
        const limitedArr2 = promiseArr.map(it => limitFunction(() => it, { concurrency: 4 }))
        Promise.all(limitedArr2).then(res => console.log(res));
        // pLimit 源码
        function validate(limit) {
            if (!Number.isInteger(limit) || limit < 0) {
                throw new Error('limit err')
            }
        }
        function pLimit(concurrency) {
            validate(concurrency)
            const queue = [];
            let running = 0;
            const next = () => {
                running--;
                if (queue.length > 0) {
                    queue.shift()()
                }
            }
            const run = async (resolve, fn, arg) => {

                running++;
                try {
                    const res = await fn(...arg);
                    resolve(res)
                } catch (e) {
                    resolve(Promise.reject(e))
                }
                next()
            }
            return (fn, ...arg) => {
                return new Promise((resolve) => {
                    if (running < concurrency) {
                        run(resolve, fn, arg)
                    } else {
                        queue.push(() => run(resolve, fn, arg))
                    }
                })
            }
        }
        function limitFunction(fn, options) {
            const concurrency = options.concurrency;
            const limit = pLimit(concurrency);
            return (...arg) => limit(() => fn(...arg))
        }
        // 100个并发请求
        async function limitRequest(arr, concurrency) {
            const indexedArr = arr.map((it, index) => ({
                index,
                promise: it.then(value => ({ key: index, value }))
            }))
            const result = [];
            const queue = indexedArr.splice(0, concurrency);
            while (queue.length > 0) {
                const { key, value } = await Promise.race(queue.map(it => it.promise))
                result[key] = value;

                const resolveIndex = queue.findIndex(it => it.index === key);
                queue.splice(resolveIndex, 1);

                if (indexedArr.length > 0) {
                    queue.push(indexedArr.pop())
                }
            }
            return result
        }
        // 分时操作
        function timeFunc(arr, count, fn) {
            // ❌ 1、创建一个 start 函数来处理循环
            const start = () => {
                for (let i = 0; i < Math.min(count || 1, arr.length); i++) {
                    // ❌ 2、应该使用 arr 边执行边移除 fn(arr[i]);
                    fn(arr.shift())
                }
            }
            let timeId;
            return () => {
                // ❌ 3、返回一个函数来定时执行 start
                timeId = setInterval(() => {
                    if (arr.length === 0) {
                        return clearInterval(timeId)
                    }
                    start()
                }, 200)
            }
        }
    </script>
</body>

</html>