<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç½‘æ˜“ç¬”è¯•é¢˜</title>
</head>
<body>
    <div>
        
    </div>
    <script>
        //  ğŸŒ¹1.é˜²æŠ–å‡½æ•°
        function debounce(callback, delay) {
            return function () {
                let outArg = arguments;
                clearTimeout(callback.timeId);
                callback.timeId = setTimeout(function() {
                    callback.apply(this, outArg);
                }, delay);
            }
        }
        

        let fun = function() {
            console.log('fun ğŸ–¨ï¸ğŸ–¨ï¸ğŸ–¨ï¸=', arguments);
        }
        // ğŸŒ¹2.èŠ‚æµå‡½æ•°
        function throttle(callback, delay) {
            let last;
            return function() {
                let now = +new Date();
                let args = arguments;
                if (last && now < last + delay) {
                    clearTimeout(callback.timeId);
                    callback.timeId = setTimeout(function() {
                        last = now;
                        callback.apply(this, args);
                    }, delay);
                } else {
                    last = now;
                    callback.apply(this, args);
                }
            }
        }
        



        // ğŸŒ¹3.bind å®ç°
        function bind(func, context){
            let args = [].slice.call(arguments, 2);
            return function() {
                func.apply(context, args.concat([].slice.call(arguments)));
            }
        }

        function callback() {
            console.log(this.value);
        }
        const obj =  {
            value: 1
        }

        const f = bind(callback, obj, '1111')

        f('22222') //è¾“å‡º 1

        // ğŸŒ¹4.äº‹ä»¶ç³»ç»Ÿ
        class Events {
            constructor(){
                this.obj = {}
            }
            on(eventName, handler) {
                if(!this.obj[eventName]){
                    this.obj[eventName] = [handler];
                }else {
                    this.obj[eventName].push(handler);
                }
            }

            off(eventName, handler) {
                if(!this.obj[eventName]){
                    console.error('not exist.');
                }else {
                    this.obj[eventName] = null;
                }
            }

            trigger(eventName, args) {
                if(!this.obj[eventName]){
                    console.error('not exist.');
                }else {
                    // è¿ç”¨æ‰“å°1åˆ°10çš„é—®é¢˜
                    for(let i=0; i<this.obj[eventName].length; i++) {
                        this.obj[eventName][i](args);
                    }
                }
            }
        }

        const events = new Events();

        events.on('click', (args) => console.log(args));

        events.trigger('click', 3) // è¾“å‡º 3


        // ğŸŒ¹ ğŸ¤”ï¸ğŸ¤”ï¸ğŸ¤”ï¸ğŸ¤”ï¸ğŸ¤”ï¸ - æ€ä¹ˆè·å¾—å¯¹è±¡æœ¬èº«çš„åç§° 5.å­—ç¬¦ä¸²æ›¿æ¢
        function replace(str, obj) {
            for(let key in obj) {
                // console.log('match', str.match(/\{.*?\}/g));
                str.replace(`{${obj}.${key}}`, `${obj.key}`);
            }
            return str
        }

        const a = {
            b: 1,
            c: 2
        }
        replace('123{a.b}456{a.c}xxx{a.d}awd', a);
        // è¾“å‡º 12314562xxx{a.d}awd

        // ğŸŒ¹6.å¤§æ•°åŠ æ³•å‡½æ•°
        // å‡è®¾Aã€Bä¸ºstringç±»å‹è¡¨ç¤ºçš„æ•°å­—ï¼Œå‡½æ•°è¾“å‡ºä¸ºä¸¤æ•°ä¹‹å’Œ
        // æ•°å­—å¯èƒ½ä¸ºéæ•´æ•°

        // è¯·å®ç°ï¼š
        function add(strNumA, strNumB){
            let maxLen = Math.max(strNumA.length, strNumB.length);
            strNumA = strNumA.padStart(maxLen, '0');
            strNumB = strNumB.padStart(maxLen, '0');
            

            let total = 0;
            let jin = 0;
            let sum = '';
            for(let i = maxLen - 1; i >= 0; i--) {
                // å¤„ç†å°æ•°ç‚¹
                if(isNaN(parseInt(strNumA[i])) || isNaN(parseInt(strNumA[i]))) {
                    continue;
                }
                total = parseInt(strNumA[i]) + parseInt(strNumB[i]) + jin;
                jin = Math.floor(total / 10);
                sum = total % 10 + sum;
            }
            if(jin === 1) {
                sum = '1' + sum;
            }
            return sum;
        }

        add('45747', '7079879') // 3.5 

        // ğŸŒ¹7.å®ç°ä¸€ä¸ªsetInterval
        function setIntervalMock(fn, time){
            function interval(){
                setTimeout(interval, time);
                fn();
            }
            setTimeout(interval, time)
        }

        let test = function() {
            console.log('2222');
        }
        setIntervalMock(test, 1000);

        // ğŸŒ¹8.åˆ¤æ–­æ‹¬å·åŒ¹é…
        // åˆ¤æ–­æ‹¬å·åŒ¹é…
        // ç»™å®šâ¼€ä¸ªåªåŒ…å« '() {} []' 6ç§å­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œå®ç°â¼€ä¸ªâ½…æ³•æ¥æ£€æµ‹è¯¥å­—ç¬¦ä¸²æ˜¯å¦åˆæ³•ï¼Œå…¶è§„åˆ™ä¸º'()'ã€'{}'ã€'[]'å¿…é¡»äº’ç›¸åŒ¹é…ï¼Œå¯åµŒå¥—ã€‚
        const isValid = () => {

        }


        // ğŸŒ¹9.å®ç°â¼€ä¸ªPromise.allSettled
        // Promise.allSettled å¯ä»¥å°†å¤šä¸ª Promise å®ä¾‹åŒ…è£…æˆâ¼€ä¸ªæ–°çš„ Promise å®ä¾‹ï¼Œå®ƒæ€»ä¼šè¿”å›â¼€ä¸ªç»“æœæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„æ¯â¼€é¡¹åˆ†åˆ«æ˜¯æ¯ä¸ª Promise çš„è¿â¾ç»“æœ
        Promise.allSettled = function (promises) {
            return new Promise((resolve, reject) => {
                promises = Array.isArray(promises) ? promises : [];
                let len = promises.length;

                const argslen = len;
                // å¦‚æœä¼ å…¥çš„æ˜¯ä¸€ä¸ªç©ºæ•°ç»„ï¼Œé‚£ä¹ˆå°±ç›´æ¥è¿”å›ä¸€ä¸ªresolvedçš„ç©ºæ•°ç»„promiseå¯¹è±¡
                if (len === 0) return resolve([]);
                // å°†ä¼ å…¥çš„å‚æ•°è½¬åŒ–ä¸ºæ•°ç»„ï¼Œèµ‹ç»™argså˜é‡
                let args = Array.prototype.slice.call(promises);
                // è®¡ç®—å½“å‰æ˜¯å¦æ‰€æœ‰çš„ promise æ‰§è¡Œå®Œæˆï¼Œæ‰§è¡Œå®Œæ¯•åˆ™resolve
                const compute = () => {
                    if(--len === 0) { 
                        resolve(args);
                    }
                }
                function resolvePromise(index, value) {
                    // åˆ¤æ–­ä¼ å…¥çš„æ˜¯å¦æ˜¯ promise ç±»å‹
                    if(value instanceof Promise) { 
                        const then = value.then;
                        then.call(value, function(val) {
                            args[index] = { status: 'fulfilled', value: val}
                            compute()
                        }, function(e) {
                            args[index] = { status: 'rejected', reason: e }
                            compute()
                        })
                    } else {
                        args[index] = { status: 'fulfilled', value: value}
                        compute()
                    }
                }

                for(let i = 0; i < argslen; i++){
                    resolvePromise(i, args[i])
                }
            })
        }

        const promise1 = Promise.resolve(3);
        const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
        const promises = [promise1, promise2];

        Promise.allSettled(promises).
        then((results) => results.forEach((result) => console.log(result.status)));

        // expected output:
        // "fulfilled"
        // "rejected"


        // ğŸŒ¹10.å®ç° Promise.all
        var p1 = function(time) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(1);
                }, time);
            });
        };
        var p2 = function(time) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(2);
                }, time);
            });
        };

        function promiseAll(promises) {
            return new Promise((resolve, reject) => {
                if(!Array.isArray(promises)) {
                    return reject(new TypeError('arguments must be an array'));
                }
                let resolvedCounter = 0;
                let promiseNum = promises.length;
                let resolvedValues = new Array(promiseNum);
                for (let i = 0; i < promiseNum; i++) {
                    Promise
                        .resolve(promises[i])
                        .then((value) => {
                            resolvedCounter++;
                            resolvedValues[i] = value;
                            if (resolvedCounter === promiseNum) {
                                resolve(resolvedValues);
                            }
                        }, (reason) => {
                            reject(reason);
                        });
                }
            });
        }

        promiseAll([p1(1000), p2(2000)]).then((r) => console.log(r));
    </script>
</body>
</html>