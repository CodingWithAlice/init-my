<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nextTick原理模拟</title>
</head>

<body>
    <script>
        const callbacks = [];
        let pending = false;  // 标记是否正在执行回调函数
        function flushCallbacks() { // 异步执行全部回调函数
            pending = false;
            const copies = callbacks.slice(0);
            copies.forEach(it => it());
        }

        // step2：根据当前浏览器环境，选择异步执行方式
        let timeFunc;
        if (typeof Promise !== 'undefined') {
            const p = Promise.resolve(); // 使用 Promise 作为微任务
            timeFunc = () => {
                p.then(flushCallbacks);
            }
        } else if (typeof MutationObserver !== 'undefined') {
            const obs = new MutationObserver(flushCallbacks); // 使用 MutationObserver 作为微任务
            let count = 1;
            const textNode = document.createTextNode(String(count));
            obs.observe(textNode, { characterData: true });
            timeFunc = () => {
                count = (count + 1) % 2;
                textNode.data = String(count);
            }
        } else if (typeof setImmediate !== 'undefined') {
            timeFunc = () => {
                setImmediate(flushCallbacks); // 使用 setImmediate 作为宏任务
            }
        } else {
            timeFunc = () => {
                setTimeout(flushCallbacks, 0); // 使用 setTimeout 作为宏任务
            }
        }

        // step3: nextTick 函数
        function nextTick(cb, ctx) {
            let _resolve;
            // step1：存储回调函数的队列
            callbacks.push(() => {
                if (cb) {
                    try { cb.call(ctx) } catch (e) { console.error(e) }
                } else if (_resolve) {
                    _resolve(ctx);
                }
            })
            // step4：执行异步任务
            if (!pending) {
                pending = true; // 正在执行回调函数
                timeFunc();
            }
            // 如果没有传入回调函数，返回一个 Promise
            if (!cb && typeof Promise !== 'undefined') {
                return new Promise(resolve => {
                    _resolve = resolve;
                })
            }
        }
        // 使用示例
        new Vue({
            data() {
                return {
                    msg: 'hello'
                }
            },
            mounted() {
                this.msg = 'world';
                // 在 DOM 更新后执行回调
                this.$nextTick(() => {
                    console.log('DOM 已经更新');
                });
            },
        })
    </script>
    <script>

        const queue = []; // 存储回调函数的队列
        let isFlushing = false; // 标记是否正在执行回调函数

        // 执行队列中的回调函数
        function flushJobs() {
            isFlushing = true;
            let job;
            while ((job = queue.shift())) {
                job();
            }
            isFlushing = false;
        }

        // nextTick 函数
        function nextTick(cb) {
            return new Promise((resolve) => {
                const runner = () => {
                    if (cb) {
                        try { cb() } catch (e) { console.error(e) }
                    }
                    resolve();
                };
                queue.push(runner);
                if (!isFlushing) {
                    queueMicrotask(flushJobs);
                }
            });
        }

        // 使用示例
        import { createApp, nextTick } from 'vue';

        const app = createApp({
            data() {
                return {
                    message: 'Hello'
                };
            },
            mounted() {
                this.message = 'World';
                nextTick(() => {
                    console.log('DOM 已经更新');
                });
            }
        });

        app.mount('#app');
    </script>
</body>

</html>