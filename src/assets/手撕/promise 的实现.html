<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>promise 的实现</title>
</head>

<body>
    <div>
        模拟实现Promise
    </div>
    <script src="../a.js">
        // promise 模型
        function Promise(fn) {
            let state = 'pending';
            let value = null;
            const callbacks = [];

            this.then = function (onFulfilled, onRejected) {
                return new Promise((resolve, reject) => {
                    handle({
                        onFulfilled,
                        onRejected,
                        resolve,
                        reject
                    })
                })
            }

            function handle(callback) {
                if (state === 'pending') {
                    callbacks.push(callback)
                    return;
                }

                const cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected;
                const next = state === 'fulfilled' ? callback.resolve : callback.reject;

                if (!cb) {
                    next(value)
                    return;
                }
                try {
                    const ret = cb(value)
                    next(ret)
                } catch (e) {
                    callback.reject(e);
                }
            }

            function resolve(newValue) {
                const fn = () => {
                    if (state !== 'pending') return

                    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                        const { then } = newValue
                        if (typeof then === 'function') {
                            // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve
                            //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调
                            then.call(newValue, resolve, reject)
                            return
                        }
                    }
                    state = 'fulfilled';
                    value = newValue
                    handelCb()
                }

                setTimeout(fn, 0)
            }
            function reject(error) {

                const fn = () => {
                    if (state !== 'pending') return

                    if (error && (typeof error === 'object' || typeof error === 'function')) {
                        const { then } = error
                        if (typeof then === 'function') {
                            then.call(error, resolve, reject)
                            return
                        }
                    }
                    state = 'rejected';
                    value = error
                    handelCb()
                }
                setTimeout(fn, 0)
            }
            function handelCb() {
                while (callbacks.length) {
                    const fn = callbacks.shift();
                    handle(fn);
                };
            }
            fn(resolve, reject)
        }

    </script>
    <script src="../a.js">
        /**
         * 明确 Promise 的几个基本信息：
         * 1、状态凝固 默认pending/resolved/rejected，改变一次后无法再变更
         * 2、传入的执行器有两个函数参数 resolve,reject，调用这两个函数触发状态变更
         * 3、执行器是同步执行的
         * 4、then 微任务执行，两个函数入参 onResolved,onRejected - catch语法糖，resolve抛出的值/reject抛出的错误原因是两个函数的参数
         * 5、then 返回的就是Promise，可以链式调用
         * 6、finally 不论返回什么值，只要改变了状态就执行
         * 7、Promise.resolve()\Promise.reject() 可以直接返回状态凝固的Promise
         * 8、Promise.all()/Promise.race()
         * */
        // 定义Promise的三种状态
        const PENDING = 'pending';
        const FULFILLED = 'fulfilled';
        const REJECTED = 'rejected';

        function MyPromise(executor) {
            let self = this;
            self.status = PENDING;
            self.value = undefined;
            self.reason = undefined;
            self.onFulfilledCallbacks = [];
            self.onRejectedCallbacks = [];

            // 模拟resolve函数，改进后可处理传入值为Promise的情况
            function resolve(value) {
                if (self === value) {
                    return reject(new TypeError('Chaining cycle detected for promise!'));
                }
                if (value instanceof MyPromise) {
                    value.then(resolve, reject);
                } else {
                    if (self.status === PENDING) {
                        self.status = FULFILLED;
                        self.value = value;
                        self.onFulfilledCallbacks.forEach(callback => callback(self.value));
                    }
                }
            }

            // 模拟reject函数，改进后可处理传入值为Promise的情况
            function reject(reason) {
                if (self.status === PENDING) {
                    self.status = REJECTED;
                    self.reason = reason;
                    self.onRejectedCallbacks.forEach(callback => callback(self.reason));
                }
            }

            try {
                executor(resolve, reject);
            } catch (e) {
                reject(e);
            }
        }

        // 模拟then方法
        MyPromise.prototype.then = function (onFulfilled, onRejected) {
            onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
            onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };
            let self = this;
            let promise2 = new MyPromise((resolve, reject) => {
                function resolveFun() {
                    try {
                        let x = onFulfilled(self.value);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejectFun() {
                    try {
                        let x = onRejected(self.reason);
                        resolvePromise(promise2, x, resolve, reject);
                    } catch (e) {
                        reject(e);
                    }
                }

                if (self.status === FULFILLED) {
                    setTimeout(resolveFun, 0);
                }
                if (self.status === REJECTED) {
                    setTimeout(rejectFun, 0);
                }
                if (self.status === PENDING) {
                    self.onFulfilledCallbacks.push(() => {
                        setTimeout(resolveFun, 0);
                    });
                    self.onRejectedCallbacks.push(() => {
                        setTimeout(rejectFun, 0);
                    });
                }
            });


            return promise2;
        }

        // 辅助函数，用于处理then中返回值是Promise或者其他情况的resolve逻辑
        function resolvePromise(promise2, x, resolve, reject) {
            if (promise2 === x) {
                return reject(new TypeError('Chaining cycle detected for promise!'));
            }
            let called = false;
            if (x instanceof MyPromise) {
                x.then(
                    y => {
                        if (called) return;
                        called = true;
                        resolvePromise(promise2, y, resolve, reject);
                    },
                    r => {
                        if (called) return;
                        called = true;
                        reject(r);
                    }
                );
            } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
                try {
                    let then = x.then;
                    if (typeof then === 'function') {
                        then.call(x,
                            y => {
                                if (called) return;
                                called = true;
                                resolvePromise(promise2, y, resolve, reject);
                            },
                            r => {
                                if (called) return;
                                called = true;
                                reject(r);
                            }
                        );
                    } else {
                        resolve(x);
                    }
                } catch (e) {
                    if (called) return;
                    called = true;
                    reject(e);
                }
            } else {
                resolve(x);
            }
        }

        // 模拟catch方法，其实就是调用then并传入处理错误的回调
        MyPromise.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }

        // 模拟finally方法，无论成功失败都会执行的逻辑
        MyPromise.prototype.finally = function (callback) {
            return this.then(
                value => MyPromise.resolve(callback()).then(() => value),
                reason => MyPromise.resolve(callback()).then(() => { throw reason; })
            );
        }

        // 模拟Promise.all方法
        MyPromise.all = function (promises) {
            return new MyPromise((resolve, reject) => {
                let result = [];
                let count = 0;
                promises.forEach((promise, index) => {
                    MyPromise.resolve(promise).then(
                        value => {
                            result[index] = value;
                            count++;
                            if (count === promises.length) {
                                resolve(result);
                            }
                        },
                        reject
                    );
                });
            });
        }

        // 模拟Promise.race方法
        MyPromise.race = function (promises) {
            return new MyPromise((resolve, reject) => {
                promises.forEach((promise) => {
                    MyPromise.resolve(promise).then(
                        resolve,
                        reject
                    );
                });
            });
        }

        // 模拟Promise.reject方法
        MyPromise.reject = function (reason) {
            return new MyPromise((resolve, reject) => {
                reject(reason);
            });
        }

        // 模拟Promise.resolve方法
        MyPromise.resolve = function (value) {
            return new MyPromise((resolve, reject) => {
                if (value instanceof MyPromise) {
                    value.then(resolve, reject);
                } else {
                    resolve(value);
                }
            });
        }
        let promise44 = MyPromise.resolve(30);
        let promise55 = MyPromise.resolve(40);
        let promise66 = MyPromise.reject(50);
        MyPromise.all([promise44, promise55, promise66]).then(values => {
            console.log('all1 success:', values);
        }).catch(reason => {
            console.log('all1 catch:', reason);
        });

    </script>
    <script src="../a.js">
        var Status = {
            pending: 'pending',
            resolve: 'fulfilled',
            reject: 'rejected'
        }
        function MyPromise1(executor) {
            let self = this;
            self.status = Status.pending;
            self.value = undefined;
            self.reason = undefined;
            self.resolvedTasks = []; // 在 resolve 函数中被执行
            self.rejectedTasks = [];

            function resolve(value) {
                if (self.status === Status.pending) {

                    self.status = Status.resolve;
                    self.value = value;
                    self.resolvedTasks.forEach(it => it(self.value)); // 不用setTimeout，投入该队列的都是 setTimeout 包裹的函数，模拟微任务，在同步任务执行完之后执行
                }
            }
            function reject(reason) {
                if (self.status === Status.pending) {
                    self.status = Status.reject;
                    self.reason = reason;
                    self.rejectedTasks.forEach(it => it(self.reason));
                }
            }

            try {
                executor(resolve, reject);
            } catch (e) {
                reject(e)
            }
        }
        MyPromise1.prototype.then = function (onResolved, onRejected) {
            onResolved = typeof onResolved === 'function' ? onResolved : value => value;
            onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };

            const promise2 = new MyPromise1((resolve, reject) => {
                const resolvedFunc = () => {
                    try {
                        const res = onResolved(this.value); // 不是执行所有回调，而是把当前传入回调函数执行
                        resolve(res);
                    } catch (e) {
                        reject(e);
                    }
                }
                const rejectedFunc = () => {
                    try {
                        const res = onRejected(this.reason);
                        resolve(res);
                    } catch (e) {
                        reject(e);
                    }
                }
                switch (this.status) {
                    case Status.resolve:
                        setTimeout(resolvedFunc, 0); // 模拟微任务，在同步任务执行完后执行
                        break;
                    case Status.reject:
                        setTimeout(rejectedFunc, 0); // 模拟微任务，在同步任务执行完后执行
                        break;
                    case Status.pending:
                        this.resolvedTasks.push(() => setTimeout(resolvedFunc, 0));
                        this.rejectedTasks.push(() => setTimeout(rejectedFunc, 0));
                        break
                }
            })
            return promise2
        }
        MyPromise1.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }
        // 状态是父期约的传递，返回值被忽略（onFinally无参数）
        MyPromise1.prototype.finally = function (callback) {
            // 状态未改变怎么办？？？ - 用 then
            return this.then(value => { callback(); return value },
                reason => { callback(); throw reason })
        }
        // 注意：then catch finally 定义在 prototype 上，依赖于实例本身的状态，操作单个实例
        // resolve reject all race 不依赖于实例，而是工具方法，作为静态方法定义

        // 传入的如果是一个 promise，会把状态和值传递下去
        MyPromise1.resolve = function (value) {
            return new MyPromise1((resolve, reject) => {
                if (value instanceof MyPromise1) {
                    value.then(resolve, reject)
                } else {
                    resolve(value)
                }
            });
        }
        MyPromise1.reject = function (reason) {
            return new MyPromise1((resolve, reject) => reject(reason));
        }
        // 返回一个 promise，都resolve则返回结果数组；有一个reject，则返回reject原因
        MyPromise1.all = function (arr) {
            return new MyPromise1((resolve, reject) => {
                arr.reduce((pre, cur, index) => {
                    cur.then((res) => {
                        pre.push(res);
                        index + 1 === arr.length && resolve(pre)
                    }, reject);
                    return pre;
                }, []);
            })
        }
        MyPromise1.race = function (arr) {
            // 哪个先结束，哪个先返回
            return new MyPromise1((resolve, reject) => {
                arr.forEach(it => MyPromise1.resolve(it).then(resolve, reject))
            })
        }
        // 测试all方法
        // let promise4 = MyPromise1.resolve(30)
        // let promise3 = MyPromise1.resolve(30)
        // let promise5 = MyPromise1.resolve(40);
        // MyPromise1.all([promise3, promise4, promise5]).then(values => {
        //     console.log('all success:', values);
        // }).catch(reason => {
        //     console.log('all catch:', reason);
        // });

        // 测试race方法
        // let promise6 = MyPromise1.resolve(5000);
        // let promise7 = new MyPromise1((resolve, reject) => {
        //     setTimeout(() => {
        //         reject('race error');
        //     }, 100);
        // });
        // let promise8 = new MyPromise1((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve('race resolve');
        //     }, 1000);
        // });
        // MyPromise1.race([promise7, promise8]).then(value => {
        //     console.log('race success:', value);
        // }).catch(reason => {
        //     console.log('race catch:', reason);
        // });
        // 测试then方法
        // let promise1 = new MyPromise1((resolve, reject) => {
        //     reject(10);
        // });
        // promise1.then(value => {
        //     console.log('then success:', value);
        // }).catch(reason => {
        //     console.log('then catch:', reason);
        // });
        // 测试catch方法
        // let promise2 = new MyPromise1((resolve, reject) => {
        //     reject('error');
        // });
        // promise2.catch(reason => {
        //     console.log('catch:', reason);
        // });
        // 测试finally方法
        // let promise3 = new MyPromise1((resolve, reject) => {
        //     resolve(20);
        // });
        // promise3.finally(() => {
        //     console.log('finally called');
        // }).then(value => {
        //     console.log('finally then success:', value);
        // });
        // 测试reject方法
        // MyPromise1.reject('reject reason').catch(reason => {
        //     console.log('reject catch:', reason);
        // });

        // 测试resolve方法
        // MyPromise1.resolve('resolved value').then(value => {
        //     console.log('resolve success:', value);
        // });
    </script>
    <script src="../a.js">
        let statusEnum = {
            resolve: 'fulfilled',
            reject: 'rejected',
            pending: 'pending'
        }
        function MyP(executor) {
            this.status = statusEnum.pending;
            this.value = undefined;
            this.reason = undefined;
            this.resolvedCallbacks = [];
            this.rejectedCallbacks = [];

            const resolve = (value) => {
                if (this.status === statusEnum.pending) {
                    this.status = statusEnum.resolve;
                    this.value = value;
                    this.resolvedCallbacks.forEach(it => it(this.value));
                }
            }
            const reject = (reason) => {
                if (this.status === statusEnum.pending) {
                    this.status = statusEnum.reject;
                    this.reason = reason;
                    this.rejectedCallbacks.forEach(it => it(this.reason));
                }
            }
            try {
                executor(resolve, reject)
            } catch (e) {
                reject(e)
            }
        }
        MyP.prototype.then = function (onFulfilled, onRejected) {
            const self = this;
            onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
            onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };

            return new MyP((resolve, reject) => {
                function onResolveFunc() {
                    try {
                        const res = onFulfilled(self.value)
                        resolve(res);
                    } catch (e) {
                        reject(e)
                    }
                }
                function onRejectFunc() {
                    try {
                        const res = onRejected(self.reason)
                        resolve(res);
                    } catch (e) {
                        reject(e)
                    }
                }

                switch (self.status) {
                    case statusEnum.resolve:
                        setTimeout(onResolveFunc, 0);
                        break;
                    case statusEnum.reject:
                        setTimeout(onRejectFunc, 0);
                        break;
                    case statusEnum.pending:
                        self.resolvedCallbacks.push(() => setTimeout(onResolveFunc, 0));
                        self.rejectedCallbacks.push(() => setTimeout(onRejectFunc, 0));
                        break;
                }
            })
        }
        MyP.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }
        MyP.prototype.finally = function (callback) {
            return this.then(value => { callback() }, // ???
                reason => { callback() })
        }
        MyP.resolve = function (value) {
            return new MyP((resolve, reject) => {
                if (value instanceof MyP) {
                    // 传入的如果是一个 promise，会把状态和值传递下去
                    value.then(resolve, reject)
                } else {
                    resolve(value)
                }
            })
        }
        MyP.reject = function (reason) {
            return new MyP((resolve, reject) => {
                reject(reason);
            })
        }
        MyP.all = function (arr) {
            return new MyP((resolve, reject) => {
                arr.reduce((pre, cur, index) => {
                    cur.then(res => {
                        pre.push(res);
                        index === arr.length - 1 && resolve(pre);
                    }, e => reject(e))
                    return pre;
                }, [])
            })
        }
        MyP.race = function (arr) {
            return new MyP((resolve, reject) => {
                arr.forEach(it => MyP.resolve(it).then(resolve, reject))
            })
        }
    </script>
    <script src="../a.js">
        let S = {
            pending: 'pending',
            resolve: 'fulfilled',
            reject: 'rejected'
        }
        function MyPromise2(executor) {
            let self = this;
            self.status = S.pending;
            self.value = undefined;
            self.reason = undefined;
            self.resolvedQueue = [];
            self.rejectedQueue = [];

            function resolve(value) {
                if (self.status === S.pending) {
                    self.status = S.resolve;
                    self.value = value;
                    self.resolvedQueue.forEach(it => it(value));
                }
            }
            function reject(reason) {
                if (self.status === S.pending) {
                    self.status = S.reject;
                    self.reason = reason;
                    self.rejectedQueue.forEach(it => it(reason));
                }
            }
            try {
                executor(resolve, reject)
            } catch (e) {
                reject(e)
            }
        }
        MyPromise2.prototype.then = function (onResolved, onRejected) {
            function isFun(t) {
                return typeof t === 'function';
            }
            onResolved = isFun(onResolved) ? onResolved : value => value;
            onRejected = isFun(onRejected) ? onRejected : reason => { throw reason };
            let self = this;

            return new MyPromise2((resolve, reject) => {
                function resolveFun() {
                    setTimeout(() => {
                        const res = onResolved(self.value); // 这里的 this 究竟是哪里的 this - 外面的
                        resolve(res);
                    }, 0);
                }
                function rejectFun() {
                    setTimeout(() => {
                        const res = onRejected(self.reason);
                        reject(res);
                    }, 0);
                }
                switch (self.status) {
                    case S.resolve:
                        resolveFun();
                        break;
                    case S.reject:
                        rejectFun();
                        break;
                    case S.pending:
                        self.resolvedQueue.push(() => resolveFun());
                        self.rejectedQueue.push(() => rejectFun());
                        break;
                }
            })
        }

        MyPromise2.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }

        MyPromise2.prototype.finally = function (callback) {
            return this.then(value => { callback(); return value; },
                reason => { callback(); throw reason; })
        }

        MyPromise2.resolve = function (value) {
            return new MyPromise2((resolve, reject) => {
                if (value instanceof MyPromise2) {
                    value.then(resolve, reject);
                } else {
                    resolve(value);
                }
            })
        }

        MyPromise2.reject = function (value) {
            return new MyPromise2((resolve, reject) => {
                reject(value);
            })
        }

        MyPromise2.all = function (arr) {
            return new MyPromise2((resolve, reject) => {
                arr.reduce((pre, cur, index) => {
                    cur.then(res => {
                        pre.push(res);
                        index === arr.length - 1 && resolve(pre);
                    }, reject);
                    return pre
                }, [])
            })
        }

        MyPromise2.race = function (arr) {
            return new MyPromise2((resolve, reject) => {
                arr.forEach(it => MyPromise1.resolve(it).then(resolve, reject));
            })
        }
    </script>
    <script src="../a.js">
        let SE = {
            pending: 'pending',
            resolved: 'fulfilled',
            reject: 'rejected'
        }
        function MyPromise3(executor) {
            this.status = SE.pending;
            this.value = null;
            this.reason = null;
            this.resolvedCallbackList = [];
            this.rejectedCallbackList = [];

            const resolve = (value) => {
                if (this.status === SE.pending) {
                    this.status = SE.resolved;
                    this.value = value;
                    this.resolvedCallbackList.forEach(it => it(value));
                }
            }

            const reject = (reason) => {
                if (this.status === SE.pending) {
                    this.status = SE.reject;
                    this.reason = reason;
                    this.rejectedCallbackList.forEach(it => it(reason));
                }
            }

            try { executor(resolve, reject) } catch (e) { reject(e) }
        }
        MyPromise3.prototype.then = function (onResolved, onRejected) {
            onResolved = typeof onResolved === 'function' ? onResolved : value => value;
            onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };
            let self = this;

            return new MyPromise3((resolve, reject) => {
                const resolveFun = () => {
                    setTimeout(() => {
                        try {
                            const res = onResolved(self.value);
                            resolve(res);
                        } catch (e) {
                            reject(e)
                        }
                    }, 0);
                }
                const rejectFun = () => {
                    setTimeout(() => {
                        try {
                            const res = onRejected(self.reason);
                            reject(res);
                        } catch (e) {
                            reject(e)
                        }
                    }, 0);
                }
                if (self.status === SE.resolved) { resolveFun(); }
                if (self.status === SE.reject) { rejectFun(); }
                if (self.status === SE.pending) {
                    this.resolvedCallbackList.push(() => resolveFun())
                    this.rejectedCallbackList.push(() => rejectFun())
                }
            })
        }
        MyPromise3.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }
        MyPromise3.prototype.finally = function (callback) {
            return this.then(value => { callback(); return value; },
                reason => { callback(); throw reason; })
        }
        MyPromise3.resolve = function (value) {
            return new MyPromise3((resolve, reject) => {
                if (value instanceof MyPromise3) {
                    value.then(resolve, reject);
                } else {
                    resolve(value)
                }
            })
        }
        MyPromise3.reject = function (reason) {
            return new MyPromise3((resolve, reject) => reject(reason))
        }
        MyPromise3.all = function (arr) {
            return new MyPromise3((resolve, reject) => {
                return arr.reduce((pre, cur, index) => {
                    cur.then(res => {
                        pre.push(res);
                        if (index === arr.length - 1) {
                            resolve(pre)
                        }
                    }).catch(reject);
                    return pre;
                }, [])
            })
        }
        MyPromise3.race = function (arr) {
            return new MyPromise3((resolve, reject) => {
                arr.forEach(it => {
                    MyPromise3.resolve(it).then(resolve, reject);
                })
            })
        }
    </script>
    <script src="../a.js">
        const Status6 = {
            pending: 'pending',
            resolved: 'fulfilled',
            rejected: 'rejected'
        }
        function MyPromise6(executor) {
            this.status = Status6.pending;
            this.value = null;
            this.reason = null;
            this.resolveCallList6 = [];
            this.rejectCallList6 = [];

            const resolve = (value) => {
                if (this.status === Status6.pending) {
                    this.status = Status6.resolved;
                    this.value = value;
                    this.resolveCallList6.forEach(it => it(value));
                }
            }
            const reject = (reason) => {
                if (this.status === Status6.pending) {
                    this.status = Status6.rejected;
                    this.reason = reason;
                    this.rejectCallList6.forEach(it => it(reason));
                }
            }

            try {
                executor(resolve, reject)
            } catch (e) {
                reject(e)
            }
        }
        MyPromise6.prototype.then = function (onResolve, onReject) {
            onResolve = typeof onResolve === 'function' ? onResolve : v => v;
            onReject = typeof onReject === 'function' ? onReject : r => { throw r };

            return new MyPromise6((resolve, reject) => {
                const resolveFun = () => {
                    setTimeout(() => {
                        try {
                            const res = onResolve(this.value);
                            resolve(res);
                        } catch (e) {
                            reject(e)
                        }
                    }, 0)
                }
                const rejectFun = () => {
                    setTimeout(() => {
                        try {
                            const res = onReject(this.reason);
                            resolve(res);
                        } catch (e) {
                            reject(e)
                        }
                    }, 0)
                }
                switch (this.status) {
                    case Status6.pending:
                        this.resolveCallList6.push(() => resolveFun());
                        this.rejectCallList6.push(() => rejectFun())
                        break;
                    case Status6.resolved:
                        resolveFun();
                        break;
                    case Status6.rejected:
                        rejectFun()
                        break;
                }
            })
        }
        MyPromise6.prototype.catch = function (onReject) {
            return this.then(null, onReject);
        }
        MyPromise6.prototype.finally = function (callback) {
            return this.then(value => { callback(); return value; },
                reason => { callback(); throw reason; })
        }
        // MyPromise.resolve = function (value) {
        //     return new MyPromise6((resolve, reject) => {
        //         if (value instanceof MyPromise6) {
        //             return value.then(resolve, reject);
        //         }
        //         resolve(value);
        //     })
        // }
        MyPromise6.resolve = (value) => {
            return new MyPromise6((resolve, reject) => {
                if (value instanceof MyPromise6) {
                    value.then(resolve, reject);
                }
                resolve(value);
            })
            // 3、这里的 return ？？？？
        }
        MyPromise6.reject = function (reason) {
            return new MyPromise6((resolve, reject) => {
                reject(reason);
            })
        }
        // MyPromise.all = function (arr) {
        //     return new MyPromise6((resolve, reject) => {
        //         arr.reduce((pre, cur, index) => {
        //             cur.then(res => {
        //                 pre.push(res);
        //                 if (index === arr.length - 1) {
        //                     resolve(pre);
        //                 }
        //             }, reject);
        //             return pre;
        //         }, [])
        //     })
        // }
        MyPromise6.all = function (arr) {
            return new MyPromise6((resolve, reject) => {
                arr.reduce((pre, cur, index) => {
                    // 4、这里的 return 可以省略 ？？？？
                    cur.then(res => {
                        pre.push(res);
                        if (index === arr.length - 1) {
                            resolve(pre);
                        }
                    }, reject);
                    // 1、reject 是作为 then 的第二个函数 -> }, reject)
                    return pre;
                }, [])
            })
        }
        MyPromise6.race = function (arr) {
            return new MyPromise6((resolve, reject) => {
                arr.forEach(it => {
                    MyPromise6.resolve(it).then(resolve, reject);
                })
            })
        }
        // 测试all方法
        let promise4 = MyPromise6.resolve(30);
        let promise5 = MyPromise6.resolve(40);
        MyPromise6.all([promise4, promise5]).then(values => {
            console.log('all success:', values);
        }).catch(reason => {
            console.log('all catch:', reason);
        });
        // 测试resolve方法
        // MyPromise6.resolve('resolved value').then(value => {
        //     console.log('resolve success:', value);
        // });
    </script>
    <script src="../a.js">
        // Promise.race - MDN 返回第一个非pending状态的promise
        const fn1 = () => new Promise((resolve) => setTimeout(() => {
            console.log('Promise 1 resolved');

            resolve({ result: 'Promise 1 resolved', index: 0 });
        }, 1000));
        const fn2 = () => new Promise((resolve) => setTimeout(() => {
            console.log('Promise 2 resolved');

            resolve({ result: 'Promise 2 resolved', index: 1 })
        }, 800));
        const fn3 = () => new Promise((resolve, reject) => setTimeout(() => {
            console.log('Promise 3 resolved');

            resolve({ result: 'Promise 3 resolved', index: 2 })
            // reject({ result: ('Promise 3 resolved'), index: 2 })
        }, 500));
        const fn4 = () => new Promise((resolve) => setTimeout(() => {
            console.log('Promise 4 resolved');

            resolve({ result: 'Promise 4 resolved', index: 3 })
        }, 200));
        const fn5 = () => new Promise((resolve) => setTimeout(() => {
            console.log('Promise 5 resolved');

            resolve({ result: 'Promise 5 resolved', index: 4 })
        }, 100));

        // const promiseList = [fn1(), fn2(), fn3()];
        // Promise.race(promiseList)
        //     .then(res => {
        //         console.log(111, res.index);
        //         nextF1(res.index);

        //     })
        const nextF1 = (i) => {
            promiseList.splice(i, 1);
            promiseList.push(fn4());
            Promise.race(promiseList).then(res => {
                console.log(222, res.index);
                nextF2(res.index);
            })
        }
        const nextF2 = (i) => {
            promiseList.filter(it => it.index !== i);
            promiseList.push(fn5());
            Promise.race(promiseList).then(res => {
                console.log(333, res.index);
            })
        }

        // 创建 30 个模拟请求
        const requests = Array.from({ length: 10 }, (v, index) => {
            return new Promise((resolve, reject) => {
                setTimeout(resolve, 100 * index, `${index} resolved`);
            })
        })
        function transList(list) {
            return list.map((it, index) => {
                return {
                    index,
                    promise: new Promise((resolve, reject) => {
                        it.then(value => resolve({
                            value,
                            key: index
                        }), reason => reject({
                            value: reason,
                            key: index
                        }))
                    })
                }
            })
        }
        // 执行所有请求，返回所有响应
        async function execute(questList, concurreny = 6) {
            const indexedRequests = questList.map((promise, index) => ({
                index,
                promise: promise.then(value => ({ value, key: index }))
            }));
            // 初始化并发任务列表
            const activeTasks = indexedRequests.splice(0, concurrency);
            const results = [];
            // 持续处理任务，直到所有任务完成
            while (activeTasks.length > 0) {
                const { key, value } = await Promise.race(activeTasks.map(task => task.promise));

                const resolvedIndex = activeTasks.findIndex(task => task.index === key);
                activeTasks.splice(resolvedIndex, 1); // 移除已完成的任务
                results[key] = value; // 存储结果

                // 如果还有待处理的任务，添加一个新任务到并发列表
                if (indexedRequests.length > 0) {
                    activeTasks.push(indexedRequests.shift());
                }
            }
            return results;
        }
        execute(requests).then(res => {
            console.log('res:', res);
        })

    </script>
    <script>
        const S7 = {
            pending: 'pending',
            resolved: 'fulfilled',
            rejected: 'rejected'
        }
        function MyPromise7(executor) {
            this.status = S7.pending;
            this.value = null;
            this.reason = null;
            this.resolvedCbs = [];
            this.rejectedCbs = [];
            const resolve = (value) => {
                if (this.status === S7.pending) {
                    this.status = S7.resolved;
                    this.value = value;
                    this.resolvedCbs.forEach(it => it(value))
                }
            }
            const reject = (reason) => {
                if (this.status === S7.pending) {
                    this.status = S7.rejected;
                    this.reason = reason;
                    this.rejectedCbs.forEach(it => it(reason))
                }
            }
            try {
                executor(resolve, reject);
            } catch (e) {
                reject(e);
            }
        }
        MyPromise7.prototype.then = function (onResolved, onRejected) {
            return new MyPromise7((resolve, reject) => {
                const resolveFunc = () => {
                    setTimeout(() => {
                        try {
                            const res = onResolved(this.value);
                            resolve(res)
                        } catch (e) { reject(e) }
                    }, 0);
                }
                const rejectFunc = () => {
                    setTimeout(() => {
                        try {
                            const res = onRejected(this.reason);
                            resolve(res)
                        } catch (e) { reject(e) }
                    }, 0);
                }
                switch (this.status) {
                    case S7.pending:
                        this.resolvedCbs.push(resolveFunc);
                        this.rejectedCbs.push(rejectFunc);
                        break;
                    case S7.resolved:
                        this.resolvedCbs.push(resolveFunc());
                        break;
                    case S7.rejected:
                        this.rejectedCbs.push(rejectFunc());
                        break;
                }
            })
        }
        MyPromise7.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }
        MyPromise7.prototype.finally = function (cb) {
            return this.then(v => { cb(); return v }, r => { cb(); throw r })
        }
        MyPromise7.resolve = function (value) {
            return new MyPromise((resolve, reject) => {
                if (value instanceof MyPromise7) {
                    return value.then(resolve, reject)
                }
                resolve(value);
            })
        }
        MyPromise7.reject = function (reason) {
            return new MyPromise7((resolve, reject) => reject(reason))
        }
        MyPromise7.all = function (arr) {
            return new MyPromise7((resolve, reject) => {
                if (!arr.length) { resolve([]); return }
                let count = 0;
                const result = [];
                arr.forEach((it, index) => {
                    MyPromise7.resolve(it).then(res => {
                        count++;
                        result[index] = res;
                        if (count === arr.length) {
                            resolve(result)
                        }
                    }).catch(reject);
                })
            })
        }
        MyPromise7.race = function (arr) {
            return new MyPromise7((resolve, reject) => {
                arr.forEach(it => it(resolve, reject))
            })
        }
        MyPromise7.allSettled = function (arr) {
            return new MyPromise7((resolve) => {
                if (!arr.length) { resolve([]); return; }
                const result = [];
                let count = 0;
                arr.forEach((it, index) => {
                    MyPromise7.resolve(it).then(value => {
                        result[index] = { status: S7.resolved, value }
                    }).catch(reason => {
                        result[index] = { status: S7.rejected, reason }
                    }).finally(() => {
                        count++;
                        if (count === arr.length) { resolve(result) }
                    })
                })
            })
        }
        const getErr = info => new AggregateError(info, 'all rejected')
        MyPromise7.any = function (arr) {
            return new MyPromise7((resolve, reject) => {
                if (!arr.length) { reject(getErr([])); return; }
                const result = [];
                let count = 0;
                arr.forEach((it, index) => {
                    MyPromise7.resolve(it).then(resolve).catch(reason => {
                        count++;
                        result[index] = reason;
                        if (count === arr.length) { reject(getErr(results)) }
                    })
                })
            })
        }
    </script>
</body>

</html>